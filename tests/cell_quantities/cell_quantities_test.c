/** MPC simulations.
 *
 * Author: Leonor Garcia-Gutierrez, 2013
 * Version: mpcSim-1.0
 *
 *
 * METHODS:
 * populate
 * export_data
 * export_vtk_plasma
 * export_vtk_gid
 * export_vessel_geometry
 *
 * mpc_paraview.py IS NOT CREATED BY THIS CODE.
 *
 * To lauch paraview from the python script: paraview --script=mpc_paraview.py &
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include<time.h>
#include<assert.h>
#include <string.h>

#include "mpc.h"    /*  Struct definitions, function prototypes and global variables that must be made available to other files  */

/* GNU GSL*/
//#include <gsl/gsl_rng.h>
//#include<gsl/gsl_randist.h>
/* See available algorithms for GSL in: */
/*  http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html   */


//#include "stream.h"
//#include "collide.h"
//#include "macros.h"

/*-------------------------------*/
/* 		METHODS   	 */
/*-------------------------------*/

// 0,1,2 equivalent to x, y, z




//////////////////////////////////////////////////////////////////////////
/// Returns the norm squared of a 3D vector 
//////////////////////////////////////////////////////////////////////////
inline double norm_sq(double * v)
{
	return v[0]*v[0]+v[1]*v[1]+v[2]*v[2];
}

//////////////////////////////////////////////////////////////////////////
/// Calculates the total linear momentum of the system (only plasma particles).
/// Input:
/// n_part - Total number of particles in the simulation box
/// m - Mass of plasma particles
/// vel - Velocity vector of all the particles (n_part x 3)
/// Output:
/// momentum_output - 3D vector with total momentum of the simulation box (sum of the momentum of all particles)
//////////////////////////////////////////////////////////////////////////
inline void total_momentum(int n_part, double m, double ** vel, double * momentum_output)
{
	/* Define variables */
	int i,j;
	
	/* Initialise output vector */
	for(j=0; j<3; j++)
	{
		momentum_output[j]=0.0;
	}
	
	/* Add momentums */
	for( i=0; i<n_part; i++) //loop over particles
	{
		for(j=0; j<3; j++) // loop over cartesian components of the velocity
		{
			momentum_output[j]+=m*vel[i][j];
		}
	}
	
	
	return; /* Back to main */
}


//////////////////////////////////////////////////////////////////////////
/// Calculates the total linear momentum of the cell (only plasma particles).
/// Input:
/// m - Mass of plasma particles
/// vel - Velocity vector of all the particles (n_part x 3)
/// cell_particles - 1D array containing the indices of the particles currently at this cell, preceded by the local particle density (length of cell_particles)
/// For example: cell_particles = {4, 102, 150, 164, 98}. This can be cell_occupation[ci], with cell_occupation being the array generated by encage()
/// Output:
/// momentum_output - 3D vector with total momentum of the cell (sum of the momentum of the particles present in the cell)
//////////////////////////////////////////////////////////////////////////
inline void cell_momentum(int * cell_particles , double m, double ** vel, double * momentum_output)
{
	/* Define variables */
	int i,j;
	
	/* Initialise output vector */
	for(j=0; j<3; j++)
	{
		momentum_output[j]=0.0;
	}
	
	/* Add momentums */
	for( i=1; i<=cell_particles[0]; i++) //loop over particles
	{
		for(j=0; j<3; j++) // loop over cartesian components of the velocity
		{			
			momentum_output[j] += m*vel[ cell_particles[i] ][j];
		}
	}
	
	return; /* Back to main */
}


//////////////////////////////////////////////////////////////////////////
/// Calculates the total kinetic energy of the simulation box (plasma particles only)
/// Input:
/// n_part - Total number of (plasma) particles in the simulation box
/// m - Mass of the particles
/// vel - Velocity array for the system
///Output:
/// Total kinetic energy of the system of n_part particles
//////////////////////////////////////////////////////////////////////////
inline double total_kinetic_energy(int n_part, double m, double ** vel)
{
	double energy = 0.0;
	int i;
	
	for(i=0; i<n_part; i++)
	{
		energy += m * norm_sq(vel[i]);
	}

	
	return 0.5*energy;
}


//////////////////////////////////////////////////////////////////////////
/// Calculates the total kinetic energy of a given cell (plasma particles only)
/// Input:
/// n_part - Total number of (plasma) particles in the simulation box
/// m - Mass of the particles
/// vel - Velocity array for the system
/// cell_particles - 1D array containing the indices of the particles currently at this cell, preceded by the local particle density (length of cell_particles)
/// For example: cell_particles = {4, 102, 150, 164, 98}. This can be cell_occupation[ci], with cell_occupation being the array generated by encage()
///Output:
/// Total kinetic energy of the system of n_part particles
//////////////////////////////////////////////////////////////////////////
inline double cell_kinetic_energy(int * cell_particles, double m, double ** vel)
{
	double energy = 0.0;
	int i;
	
	for(i=1; i<=cell_particles[0]; i++)
	{
		energy += m * norm_sq(vel[i]);
	}

	
	return 0.5*energy;
}





/*-------------------------------*/
/*		MAIN		 */
/*-------------------------------*/

int main(int argc, char **argv) {
	
	srand(time(NULL));
	
	int i,j;
	int n_cells=8;
	int max_oc=3;
	int n_part=20;

	n_cells = atoi(argv[1]);
	max_oc = atoi(argv[2]); 
	n_part = atoi(argv[3]);
	
	assert(n_cells*max_oc>=n_part);
	
	int ** cell_occupation;
	int * cell_occupation_rmo;
	int density=0;
	cell_occupation_rmo=malloc((max_oc+1)*n_cells*sizeof(int));
	if (cell_occupation_rmo==NULL) {printf("Error allocating cell_occupation_rmo in mpc.c\n"); exit(EXIT_FAILURE);}
	cell_occupation = malloc(n_cells*sizeof(int*));
	if (cell_occupation==NULL) {printf("Error allocating cell_occupation in mpc.c\n"); exit(EXIT_FAILURE);}
	
	for(i=0; i<n_cells; i++)
	{
		cell_occupation[i] = &cell_occupation_rmo[(max_oc+1)*i];		
	}
	
	/* Initialise */
	for(i=0; i<n_cells; i++)
	{
		density=(int)(max_oc+1)*(1.0*rand()/RAND_MAX); //number between 0 and maxocc, inclusive
		assert( density<=max_oc );
		
		cell_occupation[i][0] = density;
		
		for(j=1; j<=density; j++)
		{
			cell_occupation[i][j] = (int)(n_part)*(1.0*rand()/RAND_MAX);
			
		}
		
	}
	
	/* Print to screen */
	for(i=0; i<n_cells; i++)
	{
			
		for(j=0; j<=cell_occupation[i][0]; j++)
		{
			printf("\t%d",cell_occupation[i][j]);
		}
		printf("\n");
	}	
	
	
	
	double * vel_rmo;
	double ** vel;
	
	vel_rmo = malloc( 3 * n_part * sizeof(double) );
	if (vel_rmo==NULL) {printf("Error allocating vel_rmo in mpc.c\n"); exit(EXIT_FAILURE);}
	vel = malloc( n_part * sizeof(double*) );
	if (vel==NULL) {printf("Error allocating vel in mpc.c\n"); exit(EXIT_FAILURE);}
	for(i=0; i<n_part; i++)
	{
		vel[i] = &vel_rmo[3*i];
	}
	
	for(i=0; i<n_part; i++)
	{
		for(j=0; j<3; j++)
		{
			vel[i][j] = 1.0;//20.0*(1.0*rand()/RAND_MAX);
		}
	}
	
	
	double momentum_output[3]={0.0,0.0,0.0};
	double m =1.0;	
	
	/*printf("Velocity vector:\n");
	for(i=0; i<n_part; i++ )
	{
		for(j=0; j<3; j++)
		{
			printf("%.2lf\t",vel[i][j]);
		}
		printf("\n");
	}
	*/
	
	
	cell_momentum(cell_occupation[n_cells-1], m, vel, momentum_output);
	
	for( i=0; i<3; i++)
	{
		printf("%lf\t",momentum_output[i]);
	}
	printf("\n");
	
	
	double energy=0.0;
	
	energy = cell_kinetic_energy(cell_occupation[n_cells-1], m, vel);
	printf("Cell kinetic energy=%.3lf\n",energy);


	/* Clean up */
	free(cell_occupation);
	free(cell_occupation_rmo);
	free(vel);
	free(vel_rmo);
	
	return 0;
}





